/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.sg.superherosightingmvc.dao;

import com.sg.superherosightingmvc.model.Ability;
import com.sg.superherosightingmvc.model.Anomaly;
import com.sg.superherosightingmvc.model.Location;
import com.sg.superherosightingmvc.model.Organization;
import com.sg.superherosightingmvc.model.Sighting;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDate;
import java.util.List;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

/**
 *
 * @author wgv85
 */
public class SightingDaoJdbcTemplateImpl implements SightingDao {
    
    // Instantiate JdbcTemplate Object instance from bean in spring-persistence.xml
    private JdbcTemplate jdbcTemplate;
    
    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }
    
    @Override
    @Transactional(propagation = Propagation.REQUIRED, readOnly = false)
    public void addSighting(Sighting sighting) {
        
        //the update method inserts the data from the Sighting Object into into a row in the Sighting database table.
        jdbcTemplate.update(PreparedStatements.SQL_INSERT_SIGHTING,
                sighting.getSightingDate().toString(),
                sighting.getLocation().getLocationId());
        
        //this queryForObject method asks the database for the value we just inserted bc of the first parameter SQL_SELECT_LAST_INSERT_ID
        //the second parameter indicates what type of Object should be returned.
        int sightingId = jdbcTemplate.queryForObject(PreparedStatements.SQL_SELECT_LAST_INSERT_ID, Integer.class);
        
        // use the SightingId generated by the DB to set the Id for the sightingId
        sighting.setSightingId(sightingId);
        
        // delete the bridge table relationship for this sighting
        jdbcTemplate.update(PreparedStatements.SQL_DELETE_ANOMALYSIGHTING_BY_SIGHTING_ID, sightingId);
        // update the AnomalySighting bridge table
        insertAnomalySightings(sighting);
    }

    @Override
    @Transactional(propagation = Propagation.REQUIRED, readOnly = false)
    public void deleteSighting(int sightingId) {
        
        // Delete the bridge table relationship for this sighting
        jdbcTemplate.update(PreparedStatements.SQL_DELETE_ANOMALYSIGHTING_BY_SIGHTING_ID, sightingId);
        // delete the sighting
        jdbcTemplate.update(PreparedStatements.SQL_DELETE_SIGHTING,sightingId);
    }

    @Override
    @Transactional(propagation = Propagation.REQUIRED, readOnly = false)
    public void updateSighting(Sighting sighting) {
        
        // Update this Sighting Object
        jdbcTemplate.update(PreparedStatements.SQL_UPDATE_SIGHTING,
                sighting.getSightingDate().toString(),  // *Have to convert the LocalDate to a String for the DB to convert to a DATE
                sighting.getLocation().getLocationId(), // *Get the Location Id int to set Foreign key in the DB
                sighting.getSightingId());
        
        // Delete AnomalySighting relationship for this sighting
        jdbcTemplate.update(PreparedStatements.SQL_DELETE_ANOMALYSIGHTING_BY_SIGHTING_ID, sighting.getSightingId());
        // Use helper method to reset the bridge table relationship
        insertAnomalySightings(sighting);
    }

    @Override
    public Sighting getSightingById(int sightingId) {
        
        try {
            //create Sighting Model Object associated with the supplied sightingId
            Sighting sighting = jdbcTemplate.queryForObject(PreparedStatements.SQL_SELECT_SIGHTING_BY_ID, new SightingDaoJdbcTemplateImpl.SightingMapper(), sightingId);
            // get the Anomalies for this Sighting and list on Sighting
            List<Anomaly> anomalies = findAnomaliesForSighting(sighting);
            // add all the abilities associated with the Anomaly Objects in the list, to the list
            anomalies = findAbilitiesForAllAnomalies(anomalies);
            // add all of the organizations associated with the Anomaly Objects in the list, to the list
            anomalies = findOrganizationsForAllAnomalies(anomalies);
            // set the "anomalies" List to the [List<Anomaly> anomalies] property/field for this Sighting Object. 
            sighting.setAnomalies(anomalies);
            // return the requested Deluxe Sighting Object requested
            return sighting;
        } catch (EmptyResultDataAccessException ex) {
            return null;
        }
    }

    @Override
    public List<Sighting> getAllSightings() {
        
        // get all the sightings
        List<Sighting> sightings = jdbcTemplate.query(PreparedStatements.SQL_SELECT_ALL_SIGHTINGS, new SightingDaoJdbcTemplateImpl.SightingMapper());
        // Set the list of Anomalies for each sighting
        return findAnomaliesForAllSightings(sightings);
    }
    
    @Override
    public List<Sighting> getSightingsByLocationId(int locationId) {
        return jdbcTemplate.query(PreparedStatements.SQL_SELECT_SIGHTINGS_BY_LOCATION_ID, new SightingDaoJdbcTemplateImpl.SightingMapper(), locationId);
    }

    @Override
    public List<Sighting> getSightingsByAnomalyId(int anomalyId) {
        return jdbcTemplate.query(PreparedStatements.SQL_SELECT_SIGHTINGS_BY_ANOMALY_ID, new SightingDaoJdbcTemplateImpl.SightingMapper(), anomalyId);
    }
    
    @Override
    public List<Sighting> getAllSightingsByDate(LocalDate date) {
        
        //Create a List<Sighting> associated with the supplied LocalDate
        List<Sighting> sightings = jdbcTemplate.query(PreparedStatements.SQL_SELECT_ALL_SIGHTINGS_BY_DATE, new SightingDaoJdbcTemplateImpl.SightingMapper(), date.toString());
        
        //use AnomalySighting helper method to set the List<Anomaly> for each Sighting Model Object in the List<Sighting> sightings
        sightings = findAnomaliesForAllSightings(sightings);
        
        //increment through List<Sighting> sightings
        for (Sighting currentSighting : sightings) {
            
            //populate a List<Anomaly> of each Anomaly Model Object associated with the incremented Sighting Model Object
            List<Anomaly> anomalies = currentSighting.getAnomalies();
            
            //use AnomalyAbility helper method to populate [List<Ability> abilities] field for each 
            //Anomaly Model Object in the List<Anomaly> associated with the incremented Sighting Model Object
            anomalies = findAbilitiesForAllAnomalies(anomalies);
            
            //use AnomalyOrganization helper method to populate [List<Organization> organizations] field for each
            //Anomaly Model Object in the List<Anomaly> associated with the incremented Sighting Model Object
            anomalies = findOrganizationsForAllAnomalies(anomalies);
            
            //Set the [List<Anomaly> anomalies] field for the incremented Sighting Model Object
            currentSighting.setAnomalies(anomalies);
        }
        return sightings;
        
    }
    
    @Override
    public List<Sighting> getLastTenSightings() {
        
        //Create a List<Sighting> of the last 10 sightings using Prepared Statement
        List<Sighting> sightings = jdbcTemplate.query(PreparedStatements.SQL_SELECT_LAST_10_SIGHTINGS, new SightingDaoJdbcTemplateImpl.SightingMapper());
        
        //use AnomalySighting helper method to set the List<Sighting> for each Sighting Model Object on the List<Sighting> sightings
        sightings = findAnomaliesForAllSightings(sightings);
        
        //increment through List<Sighting> sightings
        for (Sighting currentSighting : sightings) {
            
            //populate a List<Anomaly> of each Anomaly Model Object associated with the incremented Sighting Model Object
            List<Anomaly> anomalies = currentSighting.getAnomalies();
            
            //use AnomalyAbility helper method to populate [List<Ability> abilities] field for each 
            //Anomaly Model Object in the List<Anomaly> associated with the incremented Sighting Model Object
            anomalies = findAbilitiesForAllAnomalies(anomalies);
            
            //use AnomalyOrganization helper method to populate [List<Organization> organizations] field for each
            //Anomaly Model Object in the List<Anomaly> associated with the incremented Sighting Model Object
            anomalies = findOrganizationsForAllAnomalies(anomalies);
            
            //Set the [List<Anomaly> anomalies] field for the incremented Sighting Model Object
            currentSighting.setAnomalies(anomalies);
        }
        return sightings;
        
    }
    
//***********************************************************************************
// AnomalyAbility HELPER METHODS
//***********************************************************************************
    
    
    private void insertAnomalyAbilities(Anomaly anomaly) {
        
        // declare and set a "helper" int from the supplied Anomaly Model Object
        final int anomalyId = anomaly.getAnomalyId();
        
        // declare and populate a List of Ability Objects using the List<Ability>
        // associated with the supplied Anomaly Model Object
        final List<Ability> abilities = anomaly.getAbilities();
        
        // Update the AnomalyAbility bridge table with the incremented ablityId and "helper" anomalyId
        for (Ability currentAbility : abilities) {
            jdbcTemplate.update(PreparedStatements.SQL_INSERT_ANOMALYABILITY, anomalyId, currentAbility.getAbilityId());
        }
    }
    
    // Retrieves all of the Abilities for the Anomaly by joinging the Anomaly and AnomalyAbility tables.
    private List<Ability> findAbilitiesForAnomaly(Anomaly anomaly) {
        
        // Use the prepared statement to return a List of every Ability associated with the supplied Anomaly Object
        return jdbcTemplate.query(PreparedStatements.SQL_SELECT_ABILITIES_BY_ANOMALY_ID, new SightingDaoJdbcTemplateImpl.AbilityMapper(), anomaly.getAnomalyId());
    }
    
    // Retrieves and adds all of the Abilities for every Anomaly in the supplied Anomaly List, returns Anomaly List
    private List<Anomaly> findAbilitiesForAllAnomalies(List<Anomaly> anomalies) {
        
        // set the [List<Ability> Abilities] field for each Anomaly in the anomalies List
        for (Anomaly currentAnomaly : anomalies) {
            currentAnomaly.setAbilities(findAbilitiesForAnomaly(currentAnomaly));
        }
        return anomalies;
    }
    

//************************************************************************************
// AnomalyOrganization HELPER METHODS
//***********************************************************************************
    
    
    private void insertAnomalyOrganizations(Anomaly anomaly) {
        
        // declare and set a "helper" int from the supplied Anomaly Model Object
        final int anomalyId  = anomaly.getAnomalyId();
        
        // declare and populate a List of Organization Objects using the List<Organization>
        // associated with the supplied Anomaly Model Object
        final List<Organization> organizations = anomaly.getOrganizations();
        
        // Update the AnomalyOrganization bridge table with the incremented organizationId and "helper" anomalyId
        for (Organization currentOrganization : organizations) {
            
            // Update AnomalyOrganization relationships
            jdbcTemplate.update(PreparedStatements.SQL_INSERT_ANOMALYORGANIZATION, anomalyId, currentOrganization.getOrganizationId());
        }
    }
    
    // Retrieves all of the Organizations for the Anomaly by joinging the Anomaly and AnomalyOrganization tables.
    private List<Organization> findOrganizationsForAnomaly(Anomaly anomaly) {
        
        // Use the prepared statement to return a List of every Organization associated with the supplied Anomaly Object
        return jdbcTemplate.query(PreparedStatements.SQL_SELECT_ORGANIZATIONS_BY_ANOMALY_ID, new SightingDaoJdbcTemplateImpl.OrganizationMapper(), anomaly.getAnomalyId());
    }
    
    // Retrieves and adds all of the Organizations for every Anomaly in the supplied Anomaly List, retrurn Anomaly List
    private List<Anomaly> findOrganizationsForAllAnomalies(List<Anomaly> anomalies) {
        
        // set the [List<Organization> Organizations] field for each Anomaly in the anomalies List
        for (Anomaly currentAnomaly : anomalies) {
            currentAnomaly.setOrganizations(findOrganizationsForAnomaly(currentAnomaly));
        }
        return anomalies;
    }

    //************************************************************************************
// AnomalySighting HELPER METHODS
//***********************************************************************************
    
    
    private void insertAnomalySightings(Sighting sighting) {
        
        // declare and set a "helper" int from the supplied Sighting Model Object's sightingId
        final int sightingId = sighting.getSightingId();
        
        // declare and populate a List of Anomaly Objects using the [List<Anomaly> anomalies] field
        // associated with the supplied Sighting Model Object
        final List<Anomaly> anomalies = sighting.getAnomalies();
        
        // Update the AnomalySighting bridge table with the incremented anomalyId and "helper" sightingId
        for (Anomaly currentAnomaly : anomalies) {
            jdbcTemplate.update(PreparedStatements.SQL_INSERT_ANOMALYSIGHTING, currentAnomaly.getAnomalyId(), sightingId);
        }
    }
    
    // Retrieves all of the Anomalies for the Sighting by joinging the Sighting and AnomalySighting tables.
    private List<Anomaly> findAnomaliesForSighting(Sighting sighting) {
        
        // Use the prepared statement to return a List of every Anomaly associated with the supplied Sighting Object
        return jdbcTemplate.query(PreparedStatements.SQL_SELECT_ANOMALYSIGHTING_BY_SIGHTING_ID, new SightingDaoJdbcTemplateImpl.AnomalyMapper(), sighting.getSightingId());
    }
    
    //Retrieves all of the Sightings for the Anomaly by joining the Anomaly and AnomalySighting tables.
    private List<Sighting> findSightingsForAnomaly(Anomaly anomaly) {
        
        //Use the prepared statement to return a List of every Sighting associated with the supplied Sighting Object
        return jdbcTemplate.query(PreparedStatements.SQL_SELECT_ANOMALYSIGHTING_BY_ANOMALY_ID, new SightingDaoJdbcTemplateImpl.SightingMapper(), anomaly.getAnomalyId());
    }
    
    
    // Retrieves and adds all of the Anomalies for every Sighting in the supplied Sighting List, return Sighting List
    private List<Sighting> findAnomaliesForAllSightings(List<Sighting> sightings) {
        
        // set the [List<Anomaly> anomalies] field for each Sighting in the sightings List
        for (Sighting currentSighting : sightings) {
            currentSighting.setAnomalies(findAnomaliesForSighting(currentSighting));
        }
        
        // return the sightings List
        return sightings;
    }
    
    // ======================================
    // ============ MAPPERS =================
    // ======================================
    //These convert rows from the different tables into equivalent Java Objects (Models).
    //JdbcTemplate allows us to use Mappers in our Java methods using the RowMapper interface.
    
    
    private static final class AnomalyMapper implements RowMapper<Anomaly> {
        
        @Override
        public Anomaly mapRow(ResultSet rs, int i) throws SQLException {
            Anomaly anomaly = new Anomaly();
            anomaly.setAnomalyName(rs.getString("AnomalyName"));
            anomaly.setAnomalyDescription(rs.getString("AnomalyDescription"));
            anomaly.setAnomalyId(rs.getInt("AnomalyId"));
            return anomaly;
        }
        
    }
    
    private static final class AbilityMapper implements RowMapper<Ability> {
        
        @Override
        public Ability mapRow(ResultSet rs, int i) throws SQLException {
            Ability ability = new Ability();
            ability.setAbilityName(rs.getString("AbilityName"));
            ability.setAbilityDescription(rs.getString("AbilityDescription"));
            ability.setAbilityId(rs.getInt("AbilityId"));
            return ability;
        }
    }
    
    private static final class OrganizationMapper implements RowMapper<Organization> {
        
        @Override
        public Organization mapRow(ResultSet rs, int i) throws SQLException {
            
            Organization org = new Organization();
            org.setOrganizationName(rs.getString("OrganizationName"));
            org.setOrganizationDescription(rs.getString("OrganizationDescription"));
            org.setOrganizationStreet(rs.getString("OrganizationStreet"));
            org.setOrganizationCity(rs.getString("OrganizationCity"));
            org.setOrganizationState(rs.getString("OrganizationState"));
            org.setOrganizationZip(rs.getString("OrganizationZip"));
            org.setOrganizationPhone(rs.getString("OrganizationPhone"));
            org.setOrganizationEmail(rs.getString("OrganizationEmail"));
            org.setOrganizationId(rs.getInt("OrganizationId"));
            return org;
        }
    }
    
    private static final class LocationMapper implements RowMapper<Location> {
        
        @Override
        public Location mapRow(ResultSet rs, int i) throws SQLException {
            Location loc = new Location();
            loc.setLocationName(rs.getString("LocationName"));
            loc.setLocationDescription(rs.getString("LocationDescription"));
            loc.setLocationStreet(rs.getString("LocationStreet"));
            loc.setLocationCity(rs.getString("LocationCity"));
            loc.setLocationState(rs.getString("LocationState"));
            loc.setLocationZip(rs.getString("LocationZip"));
            loc.setLocationLatitude(rs.getBigDecimal("LocationLatitude"));
            loc.setLocationLongitude(rs.getBigDecimal("LocationLongitude"));
            loc.setLocationId(rs.getInt("LocationId"));
            return loc;
        }
    }
    
    private static final class SightingMapper implements RowMapper<Sighting> {
        
        
        @Override
        public Sighting mapRow(ResultSet rs, int i) throws SQLException {
            Sighting sighting = new Sighting();
            sighting.setSightingDate(rs.getTimestamp("SightingDate").toLocalDateTime().toLocalDate());
            
            // Get Location Object to use as Sighting foreign key
            Location location = new Location();
            location.setLocationId(rs.getInt("LocationId"));
            location.setLocationName(rs.getString("LocationName"));
            location.setLocationDescription(rs.getString("LocationDescription"));
            location.setLocationStreet(rs.getString("LocationStreet"));
            location.setLocationCity(rs.getString("LocationCity"));
            location.setLocationState(rs.getString("LocationState"));
            location.setLocationZip(rs.getString("LocationZip"));
            location.setLocationLatitude(rs.getBigDecimal("LocationLatitude"));
            
            sighting.setLocation(location);
            sighting.setSightingId(rs.getInt("SightingId"));
            
            return sighting;
        }
    }
    
}
